from scapy.all import *from scapy.layers import http# Define a dictionary of known TTPs with their associated patterns# Define a dictionary of known TTPs with their associated patternsttp_patterns = {    # Techniques related to Lateral Movement    "T1057.001": ["smb", "smbv2"],  # Windows File Sharing    "T1021.001": ["wmi"],  # WMI Command Execution    "T1130": ["rdp"],  # Remote Desktop Protocol    "T1022": ["ssh"],  # SSH Lateral Movement    "T1133": ["dns", "http"],  # DNS Tunneling (mixing DNS and HTTP)    # Techniques related to Credential Access    "T1003": ["http", "https"],  # Web Phishing (look for specific phishing URLs/indicators)    "T1078": ["http", "https"],  # Brute Force Login (look for login attempts with high frequency)    "T1110": ["smb", "smbv2"],  # Pass-the-Hash (look for NTLM authentication)    "T1079": ["ssh"],  # SSH Brute Force (look for frequent SSH login attempts)    # Techniques related to Execution    "T1059.001": ["smtp"],  # Malicious Email Attachment (look for specific file extensions or indicators)    "T1105": ["powershell"],  # PowerShell Scripting    "T1059.002": ["http", "https"],  # Drive-by Download (look for suspicious download URLs)    "T1023": ["wscript"],  # Windows Script Host    # Techniques related to Defense Evasion    "T1057.002": ["dns"],  # DNS Spoofing (look for anomalous DNS traffic)    "T1116": ["process hiding"],  # Process Hiding Techniques (identify hidden processes)    "T1012": ["file deletion"],  # File Deletion of Security Logs    # Additional TTPs related to network protocols    "T1046": ["tcp"],  # Network Service Scanning (look for unusual TCP traffic)    "T1046": ["udp"],  # Network Service Scanning (look for unusual UDP traffic)    "T1210": ["http"],  # Exploitation of Remote Services (HTTP-based attacks)    # Include additional TTPs and patterns based on your specific needs}def extract_data_from_packet(packet):    try:        # Extract information from the packet        time = packet.time        src = packet.src        dst = packet.dst        proto = packet.proto        length = packet.len                # Check if the 'info' attribute exists        info = getattr(packet, 'info', '')        # Print the extracted information        print(f"Time: {time}, Source: {src}, Destination: {dst}, Protocol: {proto}, Length: {length}, Info: {info}")    except Exception as e:        print(f"Error extracting data from packet: {e}")def extract_mail_data(packet):    try:        # Check if the packet is SMTP protocol        if packet.haslayer(TCP) and packet[TCP].dport == 25:            # Extract mail data from SMTP request            mail_data = packet.load                        # Print the extracted mail data            print(f"SMTP Mail Data: {mail_data}")    except Exception as e:        print(f"Error extracting mail data from packet: {e}")def extract_http_data(packet):    try:        # Check if the packet is HTTP protocol        if packet.haslayer(http.HTTPRequest):            # Extract HTTP data            http_data = str(packet[http.HTTPRequest].payload)                        # Print the extracted HTTP data            print(f"HTTP Data: {http_data}")    except Exception as e:        print(f"Error extracting HTTP data from packet: {e}")def extract_dns_data(packet):    try:        # Check if the packet is DNS protocol        if packet.haslayer(DNS):            # Extract DNS data            dns_data = packet[DNS].summary()                        # Print the extracted DNS data            print(f"DNS Data: {dns_data}")    except Exception as e:        print(f"Error extracting DNS data from packet: {e}")def match_ttps(packet):    try:        # Extract protocol from the packet        proto = ""        if packet.haslayer(TCP):            proto = "tcp"        elif packet.haslayer(UDP):            proto = "udp"        elif packet.haslayer(ARP):            proto = "arp"        elif packet.haslayer(DNS):            proto = "dns"        elif packet.haslayer(http.HTTPRequest):            proto = "http"        elif packet.haslayer(TLS):            proto = "tls"        else:            proto = "unknown"                # Print protocol for debugging        print(f"Protocol: {proto}")        matched_ttps = []        for ttp, patterns in ttp_patterns.items():            for pattern in patterns:                if pattern in proto.lower():                    matched_ttps.append(ttp)                    break         # Print matched patterns for debugging        print(f"Matched Patterns: {matched_ttps}")                if not matched_ttps:            print("No TTP patterns matched.")                return matched_ttps    except Exception as e:        print(f"Error matching TTPs: {e}")def main():    try:        # Open the pcap file        pcap_file = "00A0BE0E0D3178DCD941F0CBB1DE0F0660021647663E4F84F6F0487C2B45FE50.pcap"        # Read packets from the pcap file        packets = rdpcap(pcap_file)        # Process each packet and extract data        for packet in packets:            extract_data_from_packet(packet)            extract_mail_data(packet)            extract_http_data(packet)            extract_dns_data(packet)            # Match TTPs            matched_ttps = match_ttps(packet)            print(f"Matched TTPs: {matched_ttps}")    except Exception as e:        print(f"Error: {e}")if __name__ == "__main__":    main()